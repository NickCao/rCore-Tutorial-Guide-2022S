chapter7练习
===========================================

编程作业
-------------------------------------------

进程通信：邮箱
+++++++++++++++++++++++++++++++++++++++++++

这一章我们实现了基于 pipe 的进程间通信，但是看测例就知道了，管道不太自由，我们来实现一套乍一看更靠谱的通信 syscall吧！本节要求实现邮箱机制，以及对应的 syscall。

- 邮箱说明：每个进程拥有唯一一个邮箱，基于“数据报”收发字节信息，利用环形buffer存储，读写顺序为 FIFO，不记录来源进程。每次读写单位必须为一个报文，如果用于接收的缓冲区长度不够，舍弃超出的部分（截断报文）。为了简单，邮箱中最多拥有16条报文，每条报文最大长度256字节。当邮箱满时，发送邮件（也就是写邮箱）会失败。不考虑读写邮箱的权限，也就是所有进程都能够随意给其他进程的邮箱发报。

**mailread**:

    * syscall ID：401
    * Rust接口: ``fn mailread(buf: *mut u8, len: usize)``
    * 功能：读取一个报文，如果成功返回报文长度.
    * 参数：
        * buf: 缓冲区头。
        * len：缓冲区长度。
    * 说明：
        * len > 256 按 256 处理，len < 队首报文长度且不为0，则截断报文。
        * len = 0，则不进行读取，如果没有报文读取，返回-1，否则返回0，这是用来测试是否有报文可读。
    * 可能的错误：
        * 邮箱空。
        * buf 无效。

**mailwrite**:

    * syscall ID：402
    * Rust接口: ``fn mailwrite(pid: usize, buf: *mut u8, len: usize)``
    * 功能：向对应进程邮箱插入一条报文.
    * 参数：
        * pid: 目标进程id。
        * buf: 缓冲区头。
        * len：缓冲区长度。
    * 说明：
        * len > 256 按 256 处理，
        * len = 0，则不进行写入，如果邮箱满，返回-1，否则返回0，这是用来测试是否可以发报。
        * 可以向自己的邮箱写入报文。
    * 可能的错误：
        * 邮箱满。
        * buf 无效。

实验要求
+++++++++++++++++++++++++++++++++++++++++++++
- 实现分支：ch7。
- 实验目录要求不变。
- 通过所有测例。

  在 os 目录下 ``make run BASE=1`` 加载所有测例， ``ch7_usertest`` 打包了所有你需要通过的测例，你也可以通过修改这个文件调整本地测试的内容。

  你的内核必须前向兼容，能通过前一章的所有测例。


问答作业
-------------------------------------------

(1) 举出使用 pipe 的一个实际应用的例子。

报告要求
---------------------------------------

- 简单总结你实现的功能（200字以内，不要贴代码）。
- 完成问答题。
- (optional) 你对本次实验设计及难度/工作量的看法，以及有哪些需要改进的地方，欢迎畅所欲言。
